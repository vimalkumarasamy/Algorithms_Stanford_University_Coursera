# -*- coding: utf-8 -*-
"""Inversions_Terminal_reading.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/vimalkumarasamy/Algorithms_Stanford_University_Coursera/blob/master/Divide%20and%20Conquer%20-%20Sorting%20and%20Searching%20-%20Randomized%20Algorithms/Inversions_Terminal_reading.ipynb
"""

# Parent function to create a temporary placeholder for sorted array and calling the working functions
def mergeSort(arr, n): 
    # A temp is created as array is mutable in python
    temp = [0]*n 
    return mergeSort_recursive(arr, temp, 0, n-1) 
  
# This is working function which recursively calls itself until the length of the array falls below 2, and leverages merge function to count the inversions
def mergeSort_recursive(arr, temp, left, right): 
    # For every instance of mergeSort, inversion count in it will be initiated as 0
    # integer variables are immutable in python
    inversion_count = 0
    # Left would be the first index (0) and right would be the last index -1
    # if the length of the array is less than 2, then left would be equal to right so the below indended code won't run and 0 is returned in this instance
    if left < right: 
        # Floor division to split the array approximately equal
        mid = (left + right)//2
        # recursion for left subarray
        inversion_count += mergeSort_recursive(arr, temp, left, mid) 
        # recursion for left subarray 
        inversion_count += mergeSort_recursive(arr, temp, mid + 1, right) 
        # merging operation to account for the inversions between the 2 subarrays
        inversion_count += merge(arr, temp, left, mid, right) 
    return inversion_count 
  
# This function to account for the inversions between 2 subarrays, while merging the two - the running time for this array is 0(n)
def merge(arr, temp, left, mid, right): 
    i,j,k,inversion_count = left,mid+1,left,0     
    # checking if the boundary conditions are valid for comparison
    while i <= mid and j <= right: 
        # no inversion required in this case
        if arr[i] <= arr[j]: 
            temp[k] = arr[i] 
            k += 1
            i += 1
        # inversion required
        else: 
            temp[k] = arr[j] 
            # inversion count is incremented by number of remaining elements in the left subarray+1
            inversion_count += (mid-i + 1) 
            k += 1
            j += 1
    # when the comparison ended with pending elements in either left or right array the below while loops copy it to the temp
    while i <= mid: 
        temp[k] = arr[i] 
        k += 1
        i += 1
    while j <= right: 
        temp[k] = arr[j] 
        k += 1
        j += 1
    # Ensuring that the temp array is copied to the actual array for the given range    
    for loop_var in range(left, right + 1): 
        arr[loop_var] = temp[loop_var] 
    return inversion_count

l = int(input())
arr=[]
for i in range(l):
    x=input()
    x=int(x)
    arr.append(x)

for i in range(len(arr)):
    arr[i]=int(arr[i])

x=mergeSort(arr,l)
print(x)